package main

import (
	"context"
	"encoding/json"
	"fmt"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"reflect"
	"strconv"
	"time"
    "flag"
)

// global variables
var libraryUrl string
var libraryPort int
var helpFlag bool
var coll *mongo.Collection

type Book struct {
	ApplicationID int `json:"application_id"`
	AuthorLinkMap struct {
		JohnSchember string `json:"John Schember"`
	} `json:"author_link_map"`
	AuthorSort    string `json:"author_sort"`
	AuthorSortMap struct {
		JohnSchember string `json:"John Schember"`
	} `json:"author_sort_map"`
	Authors      []string `json:"authors"`
	CategoryUrls struct {
		Authors struct {
			JohnSchember string `json:"John Schember"`
		} `json:"authors"`
		Languages struct {
		} `json:"languages"`
		Publisher struct {
		} `json:"publisher"`
		Series struct {
		} `json:"series"`
		Tags struct {
		} `json:"tags"`
	} `json:"category_urls"`
	Comments       string `json:"comments"`
	Cover          string `json:"cover"`
	FormatMetadata struct {
		Epub struct {
			Mtime time.Time `json:"mtime"`
			Path  string    `json:"path"`
			Size  int       `json:"size"`
		} `json:"epub"`
	} `json:"format_metadata"`
	Formats     []string `json:"formats"`
	Identifiers struct {
	} `json:"identifiers"`
	Languages    []string  `json:"languages"`
	LastModified time.Time `json:"last_modified"`
	MainFormat   struct {
		Epub string `json:"epub"`
	} `json:"main_format"`
	OtherFormats struct {
	} `json:"other_formats"`
	Pubdate        string        `json:"pubdate"`
	Publisher      interface{}   `json:"publisher"`
	Rating         int           `json:"rating"`
	Series         interface{}   `json:"series"`
	SeriesIndex    interface{}   `json:"series_index"`
	Tags           []interface{} `json:"tags"`
	Thumbnail      string        `json:"thumbnail"`
	Timestamp      time.Time     `json:"timestamp"`
	Title          string        `json:"title"`
	TitleSort      string        `json:"title_sort"`
	UserCategories struct {
	} `json:"user_categories"`
	UserMetadata struct {
	} `json:"user_metadata"`
	UUID     string `json:"uuid"`
	LastLoc int `json:"last_loc"`
}
type Books struct {
	books []Book
}

func printBook(book Book) {

	fmt.Print(book.ApplicationID, " ")
	fmt.Print(book.Title, " ")
	fmt.Println(" ")
}

func printListOfBooks(books Books) {
	fmt.Println("ID  Name")
	for _, value := range books.books {
		printBook(value)
	}
}

//TODO instead of passing url, library_id and port_no separately, a simple string url can be passed (generated by another function) possibly overloading this function ?
func getListOfBooks(url string, library_id string, port_no int) Books {
	//resp, err := http.Get("http://" + url + ":" + strconv.Itoa(port_no) + "/ajax/books/" + library_id)
	resp, err := http.Get("http://" + libraryUrl + ":" + strconv.Itoa(libraryPort) + "/ajax/books/" + library_id)
	if err != nil {
		fmt.Println("error ocurred")
		log.Fatalln(err)
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}
	var book Book
	var books Books
	var result map[string]interface{}
	err = json.Unmarshal([]byte(body), &result)
	if err != nil {
		log.Println(err)
	}
	for i := 1; i < 5; i++ {
		jsonString, _ := json.Marshal(result[strconv.Itoa(i)])
		if string(jsonString) == "null" {
			break
		}
		err = json.Unmarshal([]byte(jsonString), &book)
		books.books = append(books.books, book)
	}
	return books
}

//drop the database and all the docs.
func resetDB(collection *mongo.Collection, ctx context.Context) {

	collection.Drop(ctx)
}

//Initialized the database by inserting it with all the books from the calibre-server.
func initializeDB(client *mongo.Client, ctx context.Context) *mongo.Collection {
	collection := client.Database("test").Collection("books")
	resetDB(collection, ctx)
	mod := mongo.IndexModel{
		Keys: bson.M{
			"title": 1,
		}, Options: options.Index().SetUnique(true),
	}
	ind, err := collection.Indexes().CreateOne(ctx, mod)
	if err != nil {
		fmt.Println("Indexes().CreateOne() ERROR:", err)
		os.Exit(1)
	} else {
		// API call returns string of the index name
		fmt.Println("CreateOne() index:", ind)
		fmt.Println("CreateOne() type:", reflect.TypeOf(ind))
	}
	books := getListOfBooks("localhost", "Calibre_Library", 8080)
	printListOfBooks(books)
	for _, book := range books.books {
		insertResult, err := collection.InsertOne(context.TODO(), book)
		if err != nil {
			log.Println(err)
		}
		if insertResult != nil {
			fmt.Println("Inserted Multiple Documents: ", insertResult.InsertedID)
		}
	}
	return collection
}

func metadataHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method == "PATCH" {
        updateMetadata(w,r)
    } else if r.Method == "GET" {
        getMetadata(w,r)
    }
}

func updateMetadata(w http.ResponseWriter, r *http.Request) {
    var book Book
     titlereq, ok := r.URL.Query()["title"]

     if !ok || len(titlereq[0])< 1 {
         log.Println("URL param 'title' is missing ")
         return
     }

     log.Println("title query ",titlereq)
     title := titlereq[0];
     lastLocreq,ok := r.URL.Query()["last_loc"]

     if !ok || len(lastLocreq[0])< 1 {
         log.Println("URL param 'last loc' is missing ")
         return
     }

     lastLoc := lastLocreq[0];

     newLastLoc,_  := strconv.Atoi(lastLoc)


    var filter = bson.D{{ "title", title}}
    var set = bson.D{{"lastloc", newLastLoc}}
    var update = bson.D{{"$set",set}}


    err := coll.FindOneAndUpdate(context.TODO(), filter,update).Decode(&book)

    if err != nil {
        log.Println(err)
    } else {
        log.Println("lastLoc of ",book.Title," has been updated" )

        w.Header().Set("Content-Type","application/json")
        response,_ :=json.Marshal(book)
        w.Write(response)
    }

}

func getMetadata(w http.ResponseWriter, r *http.Request) {
    var book Book
     titlereq, ok := r.URL.Query()["title"]

     if !ok || len(titlereq[0])< 1 {
         log.Println("URL param 'title' is missing ")
         return
     }
     log.Println("title query ",titlereq)
     title := titlereq[0];

    var filter = bson.D{{"title",title}}

    err := coll.FindOne(context.TODO(), filter).Decode(&book)

    log.Println("metadata of ",book.Title," has been retrieved from mongodb")

    if err != nil {
        log.Println(err)
    } else {
        w.Header().Set("Content-Type","application/json")
        response,_ :=json.Marshal(book)
        w.Write(response)
    }

}



func main() {
    flag.StringVar(&libraryUrl,"library-url","localhost","The URL of the Calibre Library server")
    flag.IntVar(&libraryPort,"library-port",8080,"The Port of the Calibre Library server")
    flag.BoolVar(&helpFlag,"help",false,"help flag")
    flag.Parse()
    if(helpFlag) {
        fmt.Println("-library-url  --- The URL of the Calibre Library server")
        fmt.Println("-library-port  --- The Port of the Calibre Library server")
        fmt.Println("-help --- display different flag options")
        return;
    }
	clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")

	client, err := mongo.Connect(context.TODO(), clientOptions)
	if err != nil {
		log.Fatal(err)
	}
	err = client.Ping(context.TODO(), nil)
	if err != nil {
		log.Fatal(err)
	}
	ctx, _ := context.WithTimeout(context.Background(), 15*time.Second)
	fmt.Println("Connected to Mongodb")
	coll = initializeDB(client, ctx)
	http.HandleFunc("/mdata", metadataHandler)
	err = http.ListenAndServe(":9090", nil)
	if err != nil {
		log.Fatal("Listen and serve: ", err)
	}
	fmt.Println("Gracefull ending of program")
}
